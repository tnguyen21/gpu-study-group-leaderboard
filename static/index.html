<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GPU Kernel Leaderboard</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --bg-dark: #0f0f1a;
            --bg-main: #1a1a2e;
            --bg-editor: #16213e;
            --bg-sidebar: #12122a;
            --accent: #00d9ff;
            --accent-hover: #00b8d4;
            --text: #e0e0e0;
            --text-muted: #8892a0;
            --success: #4ade80;
            --error: #f87171;
            --warning: #fbbf24;
            --border: #2a2a4a;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
            background: var(--bg-dark);
            color: var(--text);
            height: 100vh;
            overflow: hidden;
        }

        /* Header */
        .header {
            background: var(--bg-main);
            border-bottom: 1px solid var(--border);
            padding: 0.75rem 1.5rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            height: 56px;
        }

        .header h1 {
            font-size: 1.25rem;
            font-weight: 600;
            color: var(--accent);
        }

        .header-right {
            display: flex;
            align-items: center;
            gap: 1rem;
        }

        .header-link {
            background: transparent;
            border: 1px solid var(--border);
            color: var(--text);
            border-radius: 6px;
            padding: 0.5rem 0.75rem;
            cursor: pointer;
            font-size: 0.875rem;
        }

        .header-link:hover {
            border-color: var(--accent);
            color: var(--accent);
        }

        .username-input {
            background: var(--bg-editor);
            border: 1px solid var(--border);
            border-radius: 6px;
            padding: 0.5rem 0.75rem;
            color: var(--text);
            font-size: 0.875rem;
            width: 150px;
        }

        .username-input:focus {
            outline: none;
            border-color: var(--accent);
        }

        /* Main layout */
        .main-container {
            display: flex;
            height: calc(100vh - 56px);
        }

        /* Sidebar */
        .sidebar {
            width: 280px;
            min-width: 280px;
            background: var(--bg-sidebar);
            border-right: 1px solid var(--border);
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .sidebar-section {
            padding: 1rem;
            border-bottom: 1px solid var(--border);
        }

        .sidebar-section h3 {
            font-size: 0.75rem;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            color: var(--text-muted);
            margin-bottom: 0.75rem;
        }

        .problem-list {
            list-style: none;
            max-height: 200px;
            overflow-y: auto;
        }

        .problem-list li {
            padding: 0.5rem 0.75rem;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.875rem;
            margin-bottom: 2px;
            transition: background 0.15s;
        }

        .problem-list li:hover {
            background: var(--bg-editor);
        }

        .problem-list li.active {
            background: var(--accent);
            color: var(--bg-dark);
            font-weight: 500;
        }

        .problem-info {
            flex: 1;
            overflow-y: auto;
        }

        .problem-name {
            font-size: 1rem;
            font-weight: 600;
            margin-bottom: 0.5rem;
            color: var(--text);
        }

        .problem-chapter {
            font-size: 0.8rem;
            color: var(--accent);
            margin-bottom: 0.75rem;
        }

        .problem-description {
            font-size: 0.8rem;
            color: var(--text-muted);
            line-height: 1.5;
            white-space: pre-wrap;
        }

        /* Leaderboard */
        .leaderboard-section {
            padding: 1rem;
            flex-shrink: 0;
        }

        .leaderboard-list {
            list-style: none;
            font-size: 0.8rem;
        }

        .leaderboard-list li {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.4rem 0;
            border-bottom: 1px solid var(--border);
        }

        .leaderboard-list li:last-child {
            border-bottom: none;
        }

        .leaderboard-rank {
            color: var(--text-muted);
            width: 24px;
        }

        .leaderboard-rank.gold { color: #ffd700; }
        .leaderboard-rank.silver { color: #c0c0c0; }
        .leaderboard-rank.bronze { color: #cd7f32; }

        .leaderboard-user {
            flex: 1;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .leaderboard-time {
            color: var(--success);
            font-family: monospace;
            width: 110px;
            text-align: right;
        }

        .leaderboard-btn {
            background: var(--bg-editor);
            border: 1px solid var(--border);
            color: var(--text);
            border-radius: 6px;
            padding: 0.25rem 0.5rem;
            cursor: pointer;
            font-size: 0.75rem;
            flex-shrink: 0;
        }

        .leaderboard-btn:hover {
            border-color: var(--accent);
            color: var(--accent);
        }

        /* Editor area */
        .editor-container {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .editor-header {
            background: var(--bg-main);
            border-bottom: 1px solid var(--border);
            padding: 0.5rem 1rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .editor-tabs {
            display: flex;
            gap: 0.5rem;
        }

        .editor-tab {
            background: var(--bg-editor);
            border: 1px solid var(--border);
            border-radius: 6px 6px 0 0;
            padding: 0.4rem 1rem;
            font-size: 0.8rem;
            color: var(--text-muted);
        }

        .editor-tab.active {
            background: var(--bg-editor);
            border-bottom-color: var(--bg-editor);
            color: var(--text);
        }

        .editor-actions {
            display: flex;
            gap: 0.5rem;
        }

        .btn {
            padding: 0.5rem 1rem;
            border-radius: 6px;
            font-size: 0.875rem;
            font-weight: 500;
            cursor: pointer;
            border: none;
            transition: all 0.15s;
        }

        .btn-secondary {
            background: var(--bg-editor);
            color: var(--text);
            border: 1px solid var(--border);
        }

        .btn-secondary:hover {
            background: var(--border);
        }

        .btn-primary {
            background: var(--accent);
            color: var(--bg-dark);
        }

        .btn-primary:hover {
            background: var(--accent-hover);
        }

        .btn-primary:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .editor-wrapper {
            flex: 1;
            overflow: hidden;
        }

        .cm-editor {
            height: 100%;
            font-size: 14px;
        }

        .cm-scroller {
            overflow: auto;
        }

        /* Console */
        .console-container {
            height: 180px;
            min-height: 100px;
            background: var(--bg-dark);
            border-top: 1px solid var(--border);
        }

        .console-header {
            background: var(--bg-main);
            padding: 0.5rem 1rem;
            font-size: 0.75rem;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            color: var(--text-muted);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .console-clear {
            background: none;
            border: none;
            color: var(--text-muted);
            cursor: pointer;
            font-size: 0.75rem;
        }

        .console-clear:hover {
            color: var(--text);
        }

        .console-output {
            padding: 0.75rem 1rem;
            font-family: 'Menlo', 'Monaco', 'Courier New', monospace;
            font-size: 0.8rem;
            line-height: 1.6;
            overflow-y: auto;
            height: calc(100% - 32px);
        }

        .console-line {
            margin-bottom: 0.25rem;
        }

        .console-line.info { color: var(--text-muted); }
        .console-line.success { color: var(--success); }
        .console-line.error { color: var(--error); }
        .console-line.warning { color: var(--warning); }

        /* Loading spinner */
        .spinner {
            display: inline-block;
            width: 14px;
            height: 14px;
            border: 2px solid var(--bg-dark);
            border-top-color: transparent;
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
            margin-right: 0.5rem;
            vertical-align: middle;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* Scrollbar styling */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }

        ::-webkit-scrollbar-track {
            background: var(--bg-dark);
        }

        ::-webkit-scrollbar-thumb {
            background: var(--border);
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: var(--text-muted);
        }

        /* Empty state */
        .empty-state {
            color: var(--text-muted);
            font-size: 0.875rem;
            font-style: italic;
        }

        /* Modal */
        .modal-overlay {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.6);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 9999;
        }

        .modal-overlay.open {
            display: flex;
        }

        .modal {
            width: min(900px, 92vw);
            max-height: 80vh;
            background: var(--bg-main);
            border: 1px solid var(--border);
            border-radius: 12px;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        .modal-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0.75rem 1rem;
            border-bottom: 1px solid var(--border);
        }

        .modal-body {
            padding: 1rem;
            overflow: auto;
        }

        .modal-close {
            background: transparent;
            border: 1px solid var(--border);
            color: var(--text);
            border-radius: 6px;
            padding: 0.4rem 0.75rem;
            cursor: pointer;
        }

        .profile-list {
            list-style: none;
        }

        .profile-list li {
            display: flex;
            gap: 0.75rem;
            align-items: center;
            padding: 0.6rem 0;
            border-bottom: 1px solid var(--border);
        }

        .profile-problem {
            flex: 1;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .profile-meta {
            color: var(--text-muted);
            font-size: 0.8rem;
            width: 220px;
            text-align: right;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .profile-time {
            font-family: monospace;
            color: var(--success);
            width: 110px;
            text-align: right;
        }

        .profile-btn {
            background: var(--bg-editor);
            border: 1px solid var(--border);
            color: var(--text);
            border-radius: 6px;
            padding: 0.35rem 0.6rem;
            cursor: pointer;
            font-size: 0.8rem;
        }

        .profile-btn:hover {
            border-color: var(--accent);
            color: var(--accent);
        }

        .profile-section-title {
            font-size: 0.75rem;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            color: var(--text-muted);
            margin: 0.25rem 0 0.75rem;
        }

        .code-pre {
            background: var(--bg-editor);
            border: 1px solid var(--border);
            border-radius: 10px;
            padding: 0.9rem;
            font-family: 'Menlo', 'Monaco', 'Courier New', monospace;
            font-size: 0.85rem;
            line-height: 1.5;
            white-space: pre;
            overflow: auto;
        }
    </style>
</head>
<body>
    <header class="header">
        <h1>GPU Kernel Leaderboard</h1>
        <div class="header-right">
            <button class="header-link" id="profile-btn" type="button">Profile</button>
            <label style="font-size: 0.875rem; color: var(--text-muted);">Username:</label>
            <input type="text" id="username" class="username-input" placeholder="anonymous" />
        </div>
    </header>

    <div class="modal-overlay" id="profile-modal" role="dialog" aria-modal="true" aria-label="Profile">
        <div class="modal">
            <div class="modal-header">
                <div style="font-weight: 600;">Profile</div>
                <button class="modal-close" id="profile-close" type="button">Close</button>
            </div>
            <div class="modal-body">
                <div id="profile-status" class="empty-state">Loading…</div>
                <div id="profile-best-title" class="profile-section-title" style="display:none;">Best By Problem</div>
                <ul class="profile-list" id="profile-best"></ul>
                <div id="profile-recent-title" class="profile-section-title" style="display:none; margin-top: 1rem;">Recent Submissions</div>
                <ul class="profile-list" id="profile-list"></ul>
            </div>
        </div>
    </div>

    <div class="modal-overlay" id="submission-modal" role="dialog" aria-modal="true" aria-label="Submission Code">
        <div class="modal">
            <div class="modal-header">
                <div style="font-weight: 600;" id="submission-title">Submission</div>
                <div style="display:flex; gap: 0.5rem; align-items: center;">
                    <button class="modal-close" id="submission-copy" type="button">Copy</button>
                    <button class="modal-close" id="submission-load" type="button">Load</button>
                    <button class="modal-close" id="submission-close" type="button">Close</button>
                </div>
            </div>
            <div class="modal-body">
                <pre id="submission-code" class="code-pre"></pre>
            </div>
        </div>
    </div>

    <div class="main-container">
        <aside class="sidebar">
            <div class="sidebar-section">
                <h3>Problems</h3>
                <ul class="problem-list" id="problem-list">
                    <li class="empty-state">Loading...</li>
                </ul>
            </div>

            <div class="sidebar-section problem-info" id="problem-info">
                <h3>Problem Info</h3>
                <p class="empty-state">Select a problem to view details</p>
            </div>

            <div class="leaderboard-section">
                <h3 style="font-size: 0.75rem; text-transform: uppercase; letter-spacing: 0.05em; color: var(--text-muted); margin-bottom: 0.75rem;">Leaderboard</h3>
                <ul class="leaderboard-list" id="leaderboard-list">
                    <li class="empty-state">Select a problem</li>
                </ul>
            </div>
        </aside>

        <main class="editor-container">
            <div class="editor-header">
                <div class="editor-tabs">
                    <div class="editor-tab active" id="filename-tab">solution.cu</div>
                </div>
                <div class="editor-actions">
                    <button class="btn btn-secondary" id="reset-btn">Reset</button>
                    <button class="btn btn-primary" id="submit-btn" disabled>Submit</button>
                </div>
            </div>

            <div class="editor-wrapper" id="editor"></div>

            <div class="console-container">
                <div class="console-header">
                    <span>Console Output</span>
                    <button class="console-clear" id="clear-console">Clear</button>
                </div>
                <div class="console-output" id="console-output">
                    <div class="console-line info">Select a problem to get started.</div>
                </div>
            </div>
        </main>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/monaco-editor/0.45.0/min/vs/loader.min.js"></script>

    <script>
        // State
        let problems = [];
        let currentProblem = null;
        let editor = null;
        let isSubmitting = false;
        let selectionToken = 0;

        const stubCache = new Map(); // problemId -> stubText
        const stubFetches = new Map(); // problemId -> Promise<string>
        const leaderboardCache = new Map(); // problemId -> { data, fetchedAtMs }
        const leaderboardFetches = new Map(); // problemId -> Promise<any>
        const modelsByProblemId = new Map(); // problemId -> { model, originalStub }

        const LEADERBOARD_TTL_MS = 10_000;
        let modalBaseHost = null; // "workspace--kernel-leaderboard" (no -endpoint suffix)
        let problemListClickBound = false;

        // DOM elements
        const problemList = document.getElementById('problem-list');
        const problemInfo = document.getElementById('problem-info');
        const leaderboardList = document.getElementById('leaderboard-list');
        const editorContainer = document.getElementById('editor');
        const consoleOutput = document.getElementById('console-output');
        const submitBtn = document.getElementById('submit-btn');
        const resetBtn = document.getElementById('reset-btn');
        const usernameInput = document.getElementById('username');
        const filenameTab = document.getElementById('filename-tab');
        const clearConsoleBtn = document.getElementById('clear-console');
        const profileBtn = document.getElementById('profile-btn');
        const profileModal = document.getElementById('profile-modal');
        const profileClose = document.getElementById('profile-close');
        const profileStatus = document.getElementById('profile-status');
        const profileBestTitle = document.getElementById('profile-best-title');
        const profileBest = document.getElementById('profile-best');
        const profileRecentTitle = document.getElementById('profile-recent-title');
        const profileList = document.getElementById('profile-list');
        const submissionModal = document.getElementById('submission-modal');
        const submissionClose = document.getElementById('submission-close');
        const submissionCopy = document.getElementById('submission-copy');
        const submissionLoad = document.getElementById('submission-load');
        const submissionTitle = document.getElementById('submission-title');
        const submissionCode = document.getElementById('submission-code');

        let activeSubmission = null;

        // Initialize Monaco Editor
        require.config({ paths: { vs: 'https://cdnjs.cloudflare.com/ajax/libs/monaco-editor/0.45.0/min/vs' } });

        require(['vs/editor/editor.main'], function () {
            // Define CUDA as an extension of C++
            monaco.languages.register({ id: 'cuda' });
            monaco.languages.setMonarchTokensProvider('cuda', {
                defaultToken: '',
                tokenPostfix: '.cu',
                keywords: [
                    '__global__', '__device__', '__host__', '__shared__', '__constant__',
                    'threadIdx', 'blockIdx', 'blockDim', 'gridDim', 'warpSize',
                    '__syncthreads', '__syncwarp', 'atomicAdd', 'atomicSub', 'atomicMax', 'atomicMin',
                    'atomicExch', 'atomicCAS', '__ldg', '__shfl_sync', '__shfl_down_sync',
                    'cudaMalloc', 'cudaFree', 'cudaMemcpy', 'cudaMemset', 'cudaDeviceSynchronize',
                    'dim3', 'float4', 'float2', 'int4', 'int2', 'uint4', 'uint2',
                    'auto', 'break', 'case', 'catch', 'class', 'const', 'continue',
                    'default', 'delete', 'do', 'else', 'enum', 'explicit', 'extern',
                    'false', 'for', 'friend', 'goto', 'if', 'inline', 'mutable',
                    'namespace', 'new', 'operator', 'private', 'protected', 'public',
                    'register', 'return', 'sizeof', 'static', 'struct', 'switch',
                    'template', 'this', 'throw', 'true', 'try', 'typedef', 'typename',
                    'union', 'unsigned', 'virtual', 'void', 'volatile', 'while'
                ],
                typeKeywords: [
                    'bool', 'char', 'double', 'float', 'int', 'long', 'short', 'signed',
                    'size_t', 'unsigned', 'void', 'wchar_t'
                ],
                operators: [
                    '=', '>', '<', '!', '~', '?', ':', '==', '<=', '>=', '!=',
                    '&&', '||', '++', '--', '+', '-', '*', '/', '&', '|', '^', '%',
                    '<<', '>>', '>>>', '+=', '-=', '*=', '/=', '&=', '|=', '^=',
                    '%=', '<<=', '>>=', '>>>='
                ],
                symbols: /[=><!~?:&|+\-*\/\^%]+/,
                escapes: /\\(?:[abfnrtv\\"']|x[0-9A-Fa-f]{1,4}|u[0-9A-Fa-f]{4}|U[0-9A-Fa-f]{8})/,
                tokenizer: {
                    root: [
                        [/#\s*(define|include|if|ifdef|ifndef|elif|else|endif|pragma|error|warning|undef|line)\b/, 'keyword.directive'],
                        [/[a-z_$][\w$]*/, {
                            cases: {
                                '@typeKeywords': 'keyword.type',
                                '@keywords': 'keyword',
                                '@default': 'identifier'
                            }
                        }],
                        [/[A-Z][\w\$]*/, 'type.identifier'],
                        { include: '@whitespace' },
                        [/[{}()\[\]]/, '@brackets'],
                        [/[<>](?!@symbols)/, '@brackets'],
                        [/@symbols/, {
                            cases: {
                                '@operators': 'operator',
                                '@default': ''
                            }
                        }],
                        [/\d*\.\d+([eE][\-+]?\d+)?[fFdD]?/, 'number.float'],
                        [/0[xX][0-9a-fA-F]+/, 'number.hex'],
                        [/\d+/, 'number'],
                        [/[;,.]/, 'delimiter'],
                        [/"([^"\\]|\\.)*$/, 'string.invalid'],
                        [/"/, 'string', '@string'],
                        [/'[^\\']'/, 'string'],
                        [/(')(@escapes)(')/, ['string', 'string.escape', 'string']],
                        [/'/, 'string.invalid']
                    ],
                    whitespace: [
                        [/[ \t\r\n]+/, 'white'],
                        [/\/\*/, 'comment', '@comment'],
                        [/\/\/.*$/, 'comment']
                    ],
                    comment: [
                        [/[^\/*]+/, 'comment'],
                        [/\/\*/, 'comment', '@push'],
                        [/\*\//, 'comment', '@pop'],
                        [/[\/*]/, 'comment']
                    ],
                    string: [
                        [/[^\\"]+/, 'string'],
                        [/@escapes/, 'string.escape'],
                        [/\\./, 'string.escape.invalid'],
                        [/"/, 'string', '@pop']
                    ]
                }
            });

            monaco.editor.defineTheme('kernel-dark', {
                base: 'vs-dark',
                inherit: true,
                rules: [
                    // Avoid fallback fonts when a font variant isn't available (e.g. italic/bold directives).
                    { token: 'keyword.directive', fontStyle: '' },
                ],
                colors: {}
            });

            // Create editor
            editor = monaco.editor.create(editorContainer, {
                value: '// Select a problem from the sidebar to get started\n',
                language: 'cuda',
                theme: 'kernel-dark',
                fontSize: 14,
                fontFamily: "'Fira Code', 'Cascadia Code', 'JetBrains Mono', Menlo, Monaco, monospace",
                fontLigatures: true,
                minimap: { enabled: true },
                scrollBeyondLastLine: false,
                automaticLayout: true,
                tabSize: 4,
                insertSpaces: true,
                lineNumbers: 'on',
                renderLineHighlight: 'line',
                cursorBlinking: 'smooth',
                smoothScrolling: true,
                padding: { top: 10, bottom: 10 }
            });

            // Initialize app after editor is ready
            init();
        });

        function scheduleIdle(fn) {
            if (window.requestIdleCallback) {
                window.requestIdleCallback(fn, { timeout: 1000 });
            } else {
                setTimeout(fn, 0);
            }
        }

        // Initialize app
        async function init() {
            // Load username from localStorage
            const savedUsername = localStorage.getItem('leaderboard_username');
            if (savedUsername) {
                usernameInput.value = savedUsername;
            }

            const persistUsername = () => {
                localStorage.setItem('leaderboard_username', usernameInput.value.trim());
            };

            // Save username as you type (so submit doesn't rely on blur/change).
            usernameInput.addEventListener('input', persistUsername);
            usernameInput.addEventListener('change', persistUsername);
            usernameInput.addEventListener('blur', persistUsername);

            // Compute Modal base host once (if applicable) so we can build URLs cheaply.
            const host = window.location.host;
            if (host.includes('modal.run')) {
                const match = host.match(/^(.+--kernel-leaderboard)-\w+\.modal\.run$/);
                modalBaseHost = match ? match[1] : null;
            }

            // Load problems
            await loadProblems();

            // Event listeners
            submitBtn.addEventListener('click', handleSubmit);
            resetBtn.addEventListener('click', handleReset);
            clearConsoleBtn.addEventListener('click', clearConsole);
            profileBtn.addEventListener('click', openProfile);
            profileClose.addEventListener('click', closeProfile);
            profileModal.addEventListener('click', (e) => {
                if (e.target === profileModal) closeProfile();
            });
            submissionClose.addEventListener('click', closeSubmissionModal);
            submissionModal.addEventListener('click', (e) => {
                if (e.target === submissionModal) closeSubmissionModal();
            });
            submissionCopy.addEventListener('click', copyActiveSubmission);
            submissionLoad.addEventListener('click', loadActiveSubmissionIntoEditor);
            leaderboardList.addEventListener('click', handleLeaderboardClick);
            document.addEventListener('keydown', (e) => {
                if (e.key === 'Escape') {
                    closeProfile();
                    closeSubmissionModal();
                }
            });
        }

        // API helpers
        function buildUrl(endpointWithParams) {
            // Split endpoint and query string: "leaderboard?problem_id=x" -> ["leaderboard", "problem_id=x"]
            const [endpoint, queryString] = endpointWithParams.split('?');
            const query = queryString ? `?${queryString}` : '';

            if (modalBaseHost) {
                return `https://${modalBaseHost}-${endpoint}.modal.run${query}`;
            }
            // Local development - assume same origin
            return `/${endpoint}${query}`;
        }

        async function fetchApi(endpoint, options = {}) {
            const url = buildUrl(endpoint);
            console.log(`Fetching: ${url}`);
            const response = await fetch(url, options);
            return response.json();
        }

        async function fetchStub(problemId) {
            if (stubCache.has(problemId)) return stubCache.get(problemId);
            if (stubFetches.has(problemId)) return stubFetches.get(problemId);

            const promise = (async () => {
                const data = await fetchApi(`stub?problem_id=${problemId}`);
                const stubText = data?.stub;
                if (!stubText) {
                    throw new Error(data?.error || 'Failed to load stub');
                }
                stubCache.set(problemId, stubText);
                return stubText;
            })();

            stubFetches.set(problemId, promise);
            try {
                return await promise;
            } finally {
                stubFetches.delete(problemId);
            }
        }

        async function preloadStubs() {
            try {
                const data = await fetchApi('stubs');
                const allStubs = data?.stubs || {};
                for (const [problemId, stubText] of Object.entries(allStubs)) {
                    if (typeof stubText === 'string' && stubText) {
                        stubCache.set(problemId, stubText);
                    }
                }
                scheduleIdle(warmProblemModels);
            } catch {
                // Best-effort: individual stub loads will still work.
            }
        }

        function warmProblemModels() {
            const queue = problems.map(p => p.id).filter(pid => !modelsByProblemId.has(pid) && stubCache.has(pid));
            const step = () => {
                const nextId = queue.shift();
                if (!nextId) return;
                const stubText = stubCache.get(nextId);
                if (typeof stubText === 'string') {
                    const model = monaco.editor.createModel(stubText, 'cuda');
                    modelsByProblemId.set(nextId, { model, originalStub: stubText });
                }
                if (queue.length > 0) scheduleIdle(step);
            };
            scheduleIdle(step);
        }

        async function fetchLeaderboardData(problemId, { force = false } = {}) {
            const cached = leaderboardCache.get(problemId);
            const now = Date.now();
            if (!force && cached && (now - cached.fetchedAtMs) < LEADERBOARD_TTL_MS) {
                return cached.data;
            }
            if (!force && leaderboardFetches.has(problemId)) {
                return leaderboardFetches.get(problemId);
            }

            const promise = (async () => {
                const data = await fetchApi(`leaderboard?problem_id=${problemId}`);
                leaderboardCache.set(problemId, { data, fetchedAtMs: Date.now() });
                return data;
            })();

            leaderboardFetches.set(problemId, promise);
            try {
                return await promise;
            } finally {
                leaderboardFetches.delete(problemId);
            }
        }

        function renderLeaderboard(problemId, data) {
            if (!currentProblem || currentProblem.id !== problemId) return;
            const rankings = data?.rankings || [];

            if (rankings.length === 0) {
                leaderboardList.innerHTML = '<li class="empty-state">No submissions yet</li>';
                return;
            }

            leaderboardList.innerHTML = rankings.slice(0, 10).map((r, i) => {
                const rankClass = i === 0 ? 'gold' : i === 1 ? 'silver' : i === 2 ? 'bronze' : '';
                const submissionId = r.best_submission_id;
                const codeBtn = submissionId ? `<button class="leaderboard-btn" type="button" data-submission-id="${submissionId}">Code</button>` : '';
                return `
                    <li>
                        <span class="leaderboard-rank ${rankClass}">${r.rank}.</span>
                        <span class="leaderboard-user">${escapeHtml(r.user_id)}</span>
                        <span class="leaderboard-time">${r.best_time_ms.toFixed(4)}ms</span>
                        ${codeBtn}
                    </li>
                `;
            }).join('');
        }

        async function ensureLeaderboard(problemId, { render = true, force = false, token = null } = {}) {
            if (render && currentProblem && currentProblem.id === problemId) {
                leaderboardList.innerHTML = '<li class="empty-state">Loading…</li>';
            }
            try {
                const data = await fetchLeaderboardData(problemId, { force });
                if (token !== null && token !== selectionToken) return;
                if (render) renderLeaderboard(problemId, data);
            } catch {
                if (token !== null && token !== selectionToken) return;
                if (render && currentProblem && currentProblem.id === problemId) {
                    leaderboardList.innerHTML = '<li class="empty-state">Failed to load</li>';
                }
            }
        }

        function preloadLeaderboards() {
            const ids = problems.map(p => p.id);
            let i = 0;
            const concurrency = 2;

            const pump = async () => {
                while (i < ids.length) {
                    const problemId = ids[i++];
                    await ensureLeaderboard(problemId, { render: false });
                }
            };

            for (let c = 0; c < concurrency; c++) {
                scheduleIdle(() => pump());
            }
        }

        async function loadProblems() {
            try {
                const data = await fetchApi('problems');
                problems = data.problems || [];
                renderProblemList();

                // Select first problem by default
                if (problems.length > 0) {
                    selectProblem(problems[0].id);
                }

                // Best-effort preloading to make switching snappy.
                scheduleIdle(preloadStubs);
                scheduleIdle(preloadLeaderboards);
            } catch (error) {
                log('Failed to load problems: ' + error.message, 'error');
                problemList.innerHTML = '<li class="empty-state">Failed to load problems</li>';
            }
        }

        function renderProblemList() {
            problemList.innerHTML = problems.map(p => `
                <li data-id="${escapeHtml(p.id)}" class="${currentProblem?.id === p.id ? 'active' : ''}">
                    ${escapeHtml(p.name)}
                </li>
            `).join('');

            if (!problemListClickBound) {
                problemList.addEventListener('click', (e) => {
                    const li = e.target.closest('li[data-id]');
                    if (!li) return;
                    selectProblem(li.dataset.id);
                });
                problemListClickBound = true;
            }
        }

        function updateActiveProblemInList(problemId) {
            const prev = problemList.querySelector('li.active');
            if (prev) prev.classList.remove('active');
            const escapedId = (window.CSS && CSS.escape) ? CSS.escape(problemId) : String(problemId).replaceAll('"', '\\"');
            const next = problemList.querySelector(`li[data-id="${escapedId}"]`);
            if (next) next.classList.add('active');
        }

        async function selectProblem(problemId) {
            const problem = problems.find(p => p.id === problemId);
            if (!problem) return;
            if (currentProblem && currentProblem.id === problemId) return;

            currentProblem = problem;
            selectionToken += 1;
            const token = selectionToken;
            updateActiveProblemInList(problemId);
            filenameTab.textContent = `${problemId}.cu`;
            submitBtn.disabled = false;

            // Kick off leaderboard load early (may render immediately from cache).
            const leaderboardPromise = ensureLeaderboard(problemId, { render: true, force: false, token });

            // Swap editor model as quickly as possible.
            try {
                const existing = modelsByProblemId.get(problemId);
                if (existing?.model) {
                    editor.setModel(existing.model);
                    renderProblemInfo(existing.originalStub);
                } else {
                    const stubText = await fetchStub(problemId);
                    if (token !== selectionToken) return;
                    const model = monaco.editor.createModel(stubText, 'cuda');
                    modelsByProblemId.set(problemId, { model, originalStub: stubText });
                    editor.setModel(model);
                    renderProblemInfo(stubText);
                }
            } catch (error) {
                log('Failed to load problem: ' + error.message, 'error');
            }

            await leaderboardPromise;
        }

        function renderProblemInfo(stubContent) {
            // Parse comment block from stub
            const commentMatch = stubContent.match(/\/\*\s*([\s\S]*?)\*\//);
            if (!commentMatch) {
                problemInfo.innerHTML = `
                    <h3>Problem Info</h3>
                    <div class="problem-name">${currentProblem.name}</div>
                `;
                return;
            }

            const comment = commentMatch[1];
            const lines = comment.split('\n').map(l => l.replace(/^\s*\*\s?/, '').trim());

            // Extract parts
            let name = currentProblem.name;
            let chapter = '';
            let description = [];
            let inDescription = false;

            for (const line of lines) {
                if (line.startsWith('Problem:')) {
                    name = line.replace('Problem:', '').trim();
                } else if (line.startsWith('PMPP')) {
                    chapter = line;
                } else if (line && !line.startsWith('Input:') && !line.startsWith('Output:') &&
                           !line.startsWith('Key concepts:') && !line.startsWith('Optimization')) {
                    description.push(line);
                }
            }

            problemInfo.innerHTML = `
                <h3>Problem Info</h3>
                <div class="problem-name">${name}</div>
                ${chapter ? `<div class="problem-chapter">${chapter}</div>` : ''}
                <div class="problem-description">${description.slice(0, 5).join('\n')}</div>
            `;
        }

        function setEditorContent(content) {
            const model = editor.getModel();
            if (model) {
                model.setValue(content);
            } else {
                editor.setValue(content);
            }
        }

        function getEditorContent() {
            const model = editor.getModel();
            return model ? model.getValue() : editor.getValue();
        }

        // Security: Escape HTML to prevent XSS attacks
        function escapeHtml(str) {
            if (!str) return '';
            const div = document.createElement('div');
            div.textContent = str;
            return div.innerHTML;
        }

        async function handleSubmit() {
            if (!currentProblem || isSubmitting) return;

            const username = usernameInput.value.trim() || 'anonymous';
            localStorage.setItem('leaderboard_username', username);
            const kernelSource = getEditorContent();

            if (!kernelSource.trim()) {
                log('Error: No code to submit', 'error');
                return;
            }

            isSubmitting = true;
            submitBtn.disabled = true;
            submitBtn.innerHTML = '<span class="spinner"></span>Submitting...';

            log(`Submitting to ${currentProblem.id} as "${username}"...`, 'info');

            try {
                const result = await fetchApi('submit', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        problem_id: currentProblem.id,
                        user_id: username,
                        kernel_source: kernelSource
                    })
                });

                if (result.success) {
                    log(`Success! Median time: ${result.time_ms.toFixed(4)} ms`, 'success');
                    log(`All runs: ${result.times.map(t => t.toFixed(4)).join(', ')} ms`, 'info');
                    log(`Kernel hash: ${result.kernel_hash}`, 'info');

                    // Refresh leaderboard
                    leaderboardCache.delete(currentProblem.id);
                    await ensureLeaderboard(currentProblem.id, { render: true, force: true, token: selectionToken });
                } else {
                    log(`Submission failed: ${result.error}`, 'error');
                    if (result.message) {
                        // Format compilation errors nicely
                        const msg = result.message;
                        if (msg.includes('error:')) {
                            msg.split('\n').forEach(line => {
                                if (line.trim()) log(line, 'error');
                            });
                        } else {
                            log(result.message, 'error');
                        }
                    }
                }
            } catch (error) {
                log('Network error: ' + error.message, 'error');
            } finally {
                isSubmitting = false;
                submitBtn.disabled = false;
                submitBtn.textContent = 'Submit';
            }
        }

        function openProfile() {
            const username = usernameInput.value.trim() || 'anonymous';
            localStorage.setItem('leaderboard_username', username);
            profileModal.classList.add('open');
            loadProfile(username);
        }

        function closeProfile() {
            profileModal.classList.remove('open');
        }

        async function handleLeaderboardClick(e) {
            const btn = e.target.closest('button[data-submission-id]');
            if (!btn) return;
            const submissionId = btn.getAttribute('data-submission-id');
            if (!submissionId) return;
            await openSubmissionModal(submissionId);
        }

        function closeSubmissionModal() {
            submissionModal.classList.remove('open');
            activeSubmission = null;
            submissionTitle.textContent = 'Submission';
            submissionCode.textContent = '';
        }

        async function openSubmissionModal(submissionId) {
            submissionModal.classList.add('open');
            submissionTitle.textContent = 'Loading…';
            submissionCode.textContent = 'Loading…';
            submissionCopy.disabled = true;
            submissionLoad.disabled = true;

            try {
                const data = await fetchApi(`submission?submission_id=${encodeURIComponent(submissionId)}`);
                if (!data?.submission_id) throw new Error('Bad submission payload');
                activeSubmission = data;
                submissionTitle.textContent = `${data.problem_id} · ${data.user_id} · ${Number(data.time_ms).toFixed(4)}ms`;
                submissionCode.textContent = data.kernel_source || '(no source stored)';
                submissionCopy.disabled = false;
                submissionLoad.disabled = false;
            } catch (e) {
                activeSubmission = null;
                submissionTitle.textContent = 'Failed to load';
                submissionCode.textContent = `${e.message || e}`;
            }
        }

        async function copyActiveSubmission() {
            if (!activeSubmission || typeof activeSubmission.kernel_source !== 'string') return;
            const text = activeSubmission.kernel_source;
            try {
                await navigator.clipboard.writeText(text);
                log('Copied submission code to clipboard', 'success');
            } catch {
                const ta = document.createElement('textarea');
                ta.value = text;
                ta.style.position = 'fixed';
                ta.style.left = '-9999px';
                document.body.appendChild(ta);
                ta.select();
                document.execCommand('copy');
                ta.remove();
                log('Copied submission code to clipboard', 'success');
            }
        }

        async function loadActiveSubmissionIntoEditor() {
            if (!activeSubmission || typeof activeSubmission.kernel_source !== 'string') return;
            const shouldConfirm = (() => {
                if (!currentProblem) return true;
                const model = editor?.getModel?.();
                const entry = modelsByProblemId.get(currentProblem.id);
                if (!model || !entry?.originalStub) return true;
                return model.getValue() !== entry.originalStub;
            })();
            if (shouldConfirm && !confirm('Replace current editor contents with this submission?')) return;
            await loadSubmissionIntoEditor(activeSubmission.submission_id);
            closeSubmissionModal();
        }

        async function loadProfile(username) {
            profileStatus.textContent = 'Loading…';
            profileStatus.style.display = 'block';
            profileBestTitle.style.display = 'none';
            profileRecentTitle.style.display = 'none';
            profileBest.innerHTML = '';
            profileList.innerHTML = '';

            try {
                const data = await fetchApi(`profile?user_id=${encodeURIComponent(username)}&limit=100`);
                const recent = data?.recent || [];
                const best = data?.best_by_problem || [];

                if (best.length === 0 && recent.length === 0) {
                    profileStatus.textContent = 'No submissions yet.';
                    return;
                }

                profileStatus.style.display = 'none';

                if (best.length > 0) {
                    profileBestTitle.style.display = 'block';
                    profileBest.innerHTML = best.map((r) => `
                        <li>
                            <div class="profile-problem">${escapeHtml(r.problem_name)} <span style="color: var(--text-muted);">(${escapeHtml(r.problem_id)})</span></div>
                            <div class="profile-time">${Number(r.best_time_ms).toFixed(4)}ms</div>
                            <div class="profile-meta"></div>
                        </li>
                    `).join('');
                }

                if (recent.length > 0) {
                    profileRecentTitle.style.display = 'block';
                }
                profileList.innerHTML = recent.map((r) => `
                    <li>
                        <div class="profile-problem">${escapeHtml(r.problem_name)} <span style="color: var(--text-muted);">(${escapeHtml(r.problem_id)})</span></div>
                        <div class="profile-time">${Number(r.time_ms).toFixed(4)}ms</div>
                        <div class="profile-meta">${escapeHtml(r.submitted_at)} · ${escapeHtml(r.kernel_hash || '')}</div>
                        <button class="profile-btn" type="button" data-submission-id="${r.submission_id}">Load</button>
                    </li>
                `).join('');

                profileList.querySelectorAll('button[data-submission-id]').forEach(btn => {
                    btn.addEventListener('click', async () => {
                        const id = btn.getAttribute('data-submission-id');
                        if (!id) return;
                        await loadSubmissionIntoEditor(id);
                        closeProfile();
                    });
                });
            } catch (e) {
                profileStatus.textContent = `Failed to load profile: ${e.message || e}`;
            }
        }

        async function loadSubmissionIntoEditor(submissionId) {
            try {
                const data = await fetchApi(`submission?submission_id=${encodeURIComponent(submissionId)}`);
                if (!data?.problem_id) throw new Error('Bad submission payload');
                if (typeof data?.kernel_source !== 'string') throw new Error('Missing kernel source');
                await selectProblem(data.problem_id);
                setEditorContent(data.kernel_source);
                log(`Loaded submission ${submissionId} (${data.kernel_hash || 'no hash'})`, 'info');
            } catch (e) {
                log(`Failed to load submission: ${e.message || e}`, 'error');
            }
        }

        function handleReset() {
            if (!currentProblem) return;
            const entry = modelsByProblemId.get(currentProblem.id);
            if (entry?.originalStub) {
                entry.model.setValue(entry.originalStub);
                log('Editor reset to original stub', 'info');
            }
        }

        function log(message, type = 'info') {
            const line = document.createElement('div');
            line.className = `console-line ${type}`;
            line.textContent = `> ${message}`;
            consoleOutput.appendChild(line);
            consoleOutput.scrollTop = consoleOutput.scrollHeight;
        }

        function clearConsole() {
            consoleOutput.innerHTML = '';
        }

        // App is started inside the require() callback after Monaco loads
    </script>
</body>
</html>
