<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GPU Kernel Leaderboard</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --bg-dark: #0f0f1a;
            --bg-main: #1a1a2e;
            --bg-editor: #16213e;
            --bg-sidebar: #12122a;
            --accent: #00d9ff;
            --accent-hover: #00b8d4;
            --text: #e0e0e0;
            --text-muted: #8892a0;
            --success: #4ade80;
            --error: #f87171;
            --warning: #fbbf24;
            --border: #2a2a4a;

            --sidebar-width: 320px;
            --console-height: 220px;
            --splitter-size: 6px;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
            background: var(--bg-dark);
            color: var(--text);
            height: 100vh;
            overflow: hidden;
        }

        /* Header */
        .header {
            background: var(--bg-main);
            border-bottom: 1px solid var(--border);
            padding: 0.75rem 1.5rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            height: 56px;
        }

        .header h1 {
            font-size: 1.25rem;
            font-weight: 600;
            color: var(--accent);
        }

        .header-right {
            display: flex;
            align-items: center;
            gap: 1rem;
        }

        .header-link {
            background: transparent;
            border: 1px solid var(--border);
            color: var(--text);
            border-radius: 6px;
            padding: 0.5rem 0.75rem;
            cursor: pointer;
            font-size: 0.875rem;
        }

        .header-link:hover {
            border-color: var(--accent);
            color: var(--accent);
        }

        .username-input {
            background: var(--bg-editor);
            border: 1px solid var(--border);
            border-radius: 6px;
            padding: 0.5rem 0.75rem;
            color: var(--text);
            font-size: 0.875rem;
            width: 150px;
        }

        .username-input:focus {
            outline: none;
            border-color: var(--accent);
        }

        .auth-user {
            font-size: 0.875rem;
            color: var(--text-muted);
            max-width: 240px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .auth-modal-row {
            display: flex;
            flex-direction: column;
            gap: 0.35rem;
            margin-bottom: 0.75rem;
        }

        .auth-input {
            background: var(--bg-editor);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 0.6rem 0.75rem;
            color: var(--text);
            font-size: 0.95rem;
        }

        .auth-input:focus {
            outline: none;
            border-color: var(--accent);
        }

        .auth-actions {
            display: flex;
            gap: 0.5rem;
            justify-content: flex-end;
            margin-top: 0.5rem;
        }

        /* Main layout */
        .main-container {
            display: flex;
            height: calc(100vh - 56px);
        }

        /* Sidebar */
        .sidebar {
            width: var(--sidebar-width);
            min-width: 240px;
            max-width: 560px;
            background: var(--bg-sidebar);
            border-right: 1px solid var(--border);
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .splitter {
            background: transparent;
            flex-shrink: 0;
        }

        .splitter-vertical {
            width: var(--splitter-size);
            cursor: col-resize;
            border-left: 1px solid var(--border);
            border-right: 1px solid transparent;
        }

        .splitter-vertical:hover {
            border-left-color: var(--accent);
        }

        .splitter-horizontal {
            height: var(--splitter-size);
            cursor: row-resize;
            border-top: 1px solid var(--border);
            border-bottom: 1px solid transparent;
        }

        .splitter-horizontal:hover {
            border-top-color: var(--accent);
        }

        body.resizing {
            user-select: none;
            cursor: default;
        }

        .sidebar-section {
            padding: 1rem;
            border-bottom: 1px solid var(--border);
        }

        .sidebar-section h3 {
            font-size: 0.75rem;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            color: var(--text-muted);
            margin-bottom: 0.75rem;
        }

        .problem-list {
            list-style: none;
            max-height: 200px;
            overflow-y: auto;
        }

        .problem-list li {
            padding: 0.5rem 0.75rem;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.875rem;
            margin-bottom: 2px;
            transition: background 0.15s;
        }

        .problem-list li:hover {
            background: var(--bg-editor);
        }

        .problem-list li.active {
            background: var(--accent);
            color: var(--bg-dark);
            font-weight: 500;
        }

        .problem-info {
            flex: 1;
            overflow-y: auto;
        }

        .problem-name {
            font-size: 1rem;
            font-weight: 600;
            margin-bottom: 0.5rem;
            color: var(--text);
        }

        .problem-chapter {
            font-size: 0.8rem;
            color: var(--accent);
            margin-bottom: 0.75rem;
        }

        .problem-description {
            font-size: 0.8rem;
            color: var(--text-muted);
            line-height: 1.5;
            white-space: pre-wrap;
        }

        /* Leaderboard */
        .leaderboard-section {
            padding: 1rem;
            flex-shrink: 0;
        }

        .leaderboard-list {
            list-style: none;
            font-size: 0.8rem;
        }

        .leaderboard-list li {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.4rem 0;
            border-bottom: 1px solid var(--border);
        }

        .leaderboard-list li:last-child {
            border-bottom: none;
        }

        .leaderboard-rank {
            color: var(--text-muted);
            width: 24px;
        }

        .leaderboard-rank.gold { color: #ffd700; }
        .leaderboard-rank.silver { color: #c0c0c0; }
        .leaderboard-rank.bronze { color: #cd7f32; }

        .leaderboard-user {
            flex: 1;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .leaderboard-time {
            color: var(--success);
            font-family: monospace;
            width: 96px;
            text-align: right;
        }

        .leaderboard-btn {
            background: var(--bg-editor);
            border: 1px solid var(--border);
            color: var(--text);
            border-radius: 6px;
            padding: 0.25rem 0.5rem;
            cursor: pointer;
            font-size: 0.75rem;
            flex-shrink: 0;
        }

        .leaderboard-btn:hover {
            border-color: var(--accent);
            color: var(--accent);
        }

        /* Editor area */
        .editor-container {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .editor-header {
            background: var(--bg-main);
            border-bottom: 1px solid var(--border);
            padding: 0.5rem 1rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .editor-tabs {
            display: flex;
            gap: 0.5rem;
        }

        .editor-tab {
            background: var(--bg-editor);
            border: 1px solid var(--border);
            border-radius: 6px 6px 0 0;
            padding: 0.4rem 1rem;
            font-size: 0.8rem;
            color: var(--text-muted);
        }

        .editor-tab.active {
            background: var(--bg-editor);
            border-bottom-color: var(--bg-editor);
            color: var(--text);
        }

        .editor-actions {
            display: flex;
            gap: 0.5rem;
        }

        .btn {
            padding: 0.5rem 1rem;
            border-radius: 6px;
            font-size: 0.875rem;
            font-weight: 500;
            cursor: pointer;
            border: none;
            transition: all 0.15s;
        }

        .btn-secondary {
            background: var(--bg-editor);
            color: var(--text);
            border: 1px solid var(--border);
        }

        .btn-secondary:hover {
            background: var(--border);
        }

        .btn-primary {
            background: var(--accent);
            color: var(--bg-dark);
        }

        .btn-primary:hover {
            background: var(--accent-hover);
        }

        .btn-primary:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .editor-wrapper {
            flex: 1;
            overflow: hidden;
        }

        .cm-editor {
            height: 100%;
            font-size: 14px;
        }

        .cm-scroller {
            overflow: auto;
        }

        /* Console */
        .console-container {
            height: var(--console-height);
            min-height: 100px;
            background: var(--bg-dark);
            border-top: 1px solid var(--border);
        }

        .console-header {
            background: var(--bg-main);
            padding: 0.5rem 1rem;
            font-size: 0.75rem;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            color: var(--text-muted);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .console-clear {
            background: none;
            border: none;
            color: var(--text-muted);
            cursor: pointer;
            font-size: 0.75rem;
        }

        .console-clear:hover {
            color: var(--text);
        }

        .console-output {
            padding: 0.75rem 1rem;
            font-family: 'Menlo', 'Monaco', 'Courier New', monospace;
            font-size: 0.8rem;
            line-height: 1.6;
            overflow-y: auto;
            height: calc(100% - 32px);
        }

        .console-line {
            margin-bottom: 0.25rem;
        }

        .console-line.info { color: var(--text-muted); }
        .console-line.success { color: var(--success); }
        .console-line.error { color: var(--error); }
        .console-line.warning { color: var(--warning); }

        /* Loading spinner */
        .spinner {
            display: inline-block;
            width: 14px;
            height: 14px;
            border: 2px solid var(--bg-dark);
            border-top-color: transparent;
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
            margin-right: 0.5rem;
            vertical-align: middle;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* Scrollbar styling */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }

        ::-webkit-scrollbar-track {
            background: var(--bg-dark);
        }

        ::-webkit-scrollbar-thumb {
            background: var(--border);
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: var(--text-muted);
        }

        /* Empty state */
        .empty-state {
            color: var(--text-muted);
            font-size: 0.875rem;
            font-style: italic;
        }

        /* Modal */
        .modal-overlay {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.6);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 9999;
        }

        .modal-overlay.open {
            display: flex;
        }

        .modal {
            width: min(900px, 92vw);
            max-height: 80vh;
            background: var(--bg-main);
            border: 1px solid var(--border);
            border-radius: 12px;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        .modal-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0.75rem 1rem;
            border-bottom: 1px solid var(--border);
        }

        .modal-body {
            padding: 1rem;
            overflow: auto;
        }

        .modal-close {
            background: transparent;
            border: 1px solid var(--border);
            color: var(--text);
            border-radius: 6px;
            padding: 0.4rem 0.75rem;
            cursor: pointer;
        }

        .profile-list {
            list-style: none;
        }

        .profile-list li {
            display: flex;
            gap: 0.75rem;
            align-items: center;
            padding: 0.6rem 0;
            border-bottom: 1px solid var(--border);
        }

        .profile-problem {
            flex: 1;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .profile-meta {
            color: var(--text-muted);
            font-size: 0.8rem;
            width: 220px;
            text-align: right;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .profile-time {
            font-family: monospace;
            color: var(--success);
            width: 110px;
            text-align: right;
        }

        .profile-btn {
            background: var(--bg-editor);
            border: 1px solid var(--border);
            color: var(--text);
            border-radius: 6px;
            padding: 0.35rem 0.6rem;
            cursor: pointer;
            font-size: 0.8rem;
        }

        .profile-btn:hover {
            border-color: var(--accent);
            color: var(--accent);
        }

        .profile-section-title {
            font-size: 0.75rem;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            color: var(--text-muted);
            margin: 0.25rem 0 0.75rem;
        }

        .code-pre {
            background: var(--bg-editor);
            border: 1px solid var(--border);
            border-radius: 10px;
            padding: 0.9rem;
            font-family: 'Menlo', 'Monaco', 'Courier New', monospace;
            font-size: 0.85rem;
            line-height: 1.5;
            white-space: pre;
            overflow: auto;
        }
    </style>
</head>
<body>
    <header class="header">
        <h1>GPU Kernel Leaderboard</h1>
        <div class="header-right">
            <button class="header-link" id="profile-btn" type="button">Profile</button>
            <div class="auth-user" id="auth-user">Not logged in</div>
            <button class="header-link" id="login-btn" type="button">Login</button>
            <button class="header-link" id="logout-btn" type="button" style="display:none;">Logout</button>
        </div>
    </header>

    <div class="modal-overlay" id="auth-modal" role="dialog" aria-modal="true" aria-label="Login">
        <div class="modal" style="width: min(520px, 92vw);">
            <div class="modal-header">
                <div style="font-weight: 600;" id="auth-title">Login</div>
                <button class="modal-close" id="auth-close" type="button">Close</button>
            </div>
            <div class="modal-body">
                <div id="auth-status" class="empty-state" style="display:none;"></div>
                <div class="auth-modal-row">
                    <label for="auth-username" style="font-size: 0.8rem; color: var(--text-muted);">Username</label>
                    <input id="auth-username" class="auth-input" autocomplete="username" placeholder="your_name" />
                </div>
                <div class="auth-modal-row">
                    <label for="auth-password" style="font-size: 0.8rem; color: var(--text-muted);">Password</label>
                    <input id="auth-password" class="auth-input" type="password" autocomplete="current-password" placeholder="(no reset if lost)" />
                </div>
                <div class="auth-actions">
                    <button class="btn btn-secondary" id="signup-submit" type="button">Sign up</button>
                    <button class="btn btn-primary" id="login-submit" type="button">Login</button>
                </div>
            </div>
        </div>
    </div>

    <div class="modal-overlay" id="profile-modal" role="dialog" aria-modal="true" aria-label="Profile">
        <div class="modal">
            <div class="modal-header">
                <div style="font-weight: 600;">Profile</div>
                <button class="modal-close" id="profile-close" type="button">Close</button>
            </div>
            <div class="modal-body">
                <div id="profile-status" class="empty-state">Loading…</div>
                <div id="profile-best-title" class="profile-section-title" style="display:none;">Best By Problem</div>
                <ul class="profile-list" id="profile-best"></ul>
                <div id="profile-recent-title" class="profile-section-title" style="display:none; margin-top: 1rem;">Recent Submissions</div>
                <ul class="profile-list" id="profile-list"></ul>
            </div>
        </div>
    </div>

    <div class="modal-overlay" id="submission-modal" role="dialog" aria-modal="true" aria-label="Submission Code">
        <div class="modal">
            <div class="modal-header">
                <div style="font-weight: 600;" id="submission-title">Submission</div>
                <div style="display:flex; gap: 0.5rem; align-items: center;">
                    <button class="modal-close" id="submission-copy" type="button">Copy</button>
                    <button class="modal-close" id="submission-load" type="button">Load</button>
                    <button class="modal-close" id="submission-close" type="button">Close</button>
                </div>
            </div>
            <div class="modal-body">
                <pre id="submission-code" class="code-pre"></pre>
            </div>
        </div>
    </div>

    <div class="main-container">
        <aside class="sidebar" id="sidebar">
            <div class="sidebar-section">
                <h3>Problems</h3>
                <ul class="problem-list" id="problem-list">
                    <li class="empty-state">Loading...</li>
                </ul>
            </div>

            <div class="sidebar-section problem-info" id="problem-info">
                <h3>Problem Info</h3>
                <p class="empty-state">Select a problem to view details</p>
            </div>

            <div class="leaderboard-section">
                <h3 style="font-size: 0.75rem; text-transform: uppercase; letter-spacing: 0.05em; color: var(--text-muted); margin-bottom: 0.75rem;">Leaderboard</h3>
                <ul class="leaderboard-list" id="leaderboard-list">
                    <li class="empty-state">Select a problem</li>
                </ul>
            </div>
        </aside>

        <div class="splitter splitter-vertical" id="sidebar-splitter" role="separator" aria-orientation="vertical" title="Drag to resize"></div>

        <main class="editor-container">
            <div class="editor-header">
                <div class="editor-tabs">
                    <div class="editor-tab active" id="filename-tab">solution.cu</div>
                </div>
                <div class="editor-actions">
                    <button class="btn btn-secondary" id="reset-btn">Reset</button>
                    <button class="btn btn-primary" id="submit-btn" disabled>Submit</button>
                </div>
            </div>

            <div class="editor-wrapper" id="editor"></div>

            <div class="splitter splitter-horizontal" id="console-splitter" role="separator" aria-orientation="horizontal" title="Drag to resize"></div>

            <div class="console-container">
                <div class="console-header">
                    <span>Console Output</span>
                    <button class="console-clear" id="clear-console">Clear</button>
                </div>
                <div class="console-output" id="console-output">
                    <div class="console-line info">Select a problem to get started.</div>
                </div>
            </div>
        </main>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/monaco-editor/0.45.0/min/vs/loader.min.js"></script>

    <script>
        // State
        let problems = [];
        let currentProblem = null;
        let editor = null;
        let isSubmitting = false;
        let selectionToken = 0;

        const AUTH_USER_ID_KEY = 'leaderboard_auth_user_id';
        const AUTH_TOKEN_KEY = 'leaderboard_auth_token';

        const stubCache = new Map(); // problemId -> stubText
        const stubFetches = new Map(); // problemId -> Promise<string>
        const leaderboardCache = new Map(); // problemId -> { data, fetchedAtMs }
        const leaderboardFetches = new Map(); // problemId -> Promise<any>
        const modelsByProblemId = new Map(); // problemId -> { model, originalStub }

        const LEADERBOARD_TTL_MS = 10_000;
        let problemListClickBound = false;

        // DOM elements
        const problemList = document.getElementById('problem-list');
        const problemInfo = document.getElementById('problem-info');
        const leaderboardList = document.getElementById('leaderboard-list');
        const editorContainer = document.getElementById('editor');
        const consoleOutput = document.getElementById('console-output');
        const submitBtn = document.getElementById('submit-btn');
        const resetBtn = document.getElementById('reset-btn');
        const filenameTab = document.getElementById('filename-tab');
        const clearConsoleBtn = document.getElementById('clear-console');
        const profileBtn = document.getElementById('profile-btn');
        const authUser = document.getElementById('auth-user');
        const loginBtn = document.getElementById('login-btn');
        const logoutBtn = document.getElementById('logout-btn');
        const authModal = document.getElementById('auth-modal');
        const authClose = document.getElementById('auth-close');
        const authTitle = document.getElementById('auth-title');
        const authStatus = document.getElementById('auth-status');
        const authUsername = document.getElementById('auth-username');
        const authPassword = document.getElementById('auth-password');
        const loginSubmit = document.getElementById('login-submit');
        const signupSubmit = document.getElementById('signup-submit');
        const profileModal = document.getElementById('profile-modal');
        const profileClose = document.getElementById('profile-close');
        const profileStatus = document.getElementById('profile-status');
        const profileBestTitle = document.getElementById('profile-best-title');
        const profileBest = document.getElementById('profile-best');
        const profileRecentTitle = document.getElementById('profile-recent-title');
        const profileList = document.getElementById('profile-list');
        const submissionModal = document.getElementById('submission-modal');
        const submissionClose = document.getElementById('submission-close');
        const submissionCopy = document.getElementById('submission-copy');
        const submissionLoad = document.getElementById('submission-load');
        const submissionTitle = document.getElementById('submission-title');
        const submissionCode = document.getElementById('submission-code');
        const sidebar = document.getElementById('sidebar');
        const sidebarSplitter = document.getElementById('sidebar-splitter');
        const consoleContainer = document.querySelector('.console-container');
        const consoleSplitter = document.getElementById('console-splitter');

        let activeSubmission = null;

        // Initialize Monaco Editor
        require.config({ paths: { vs: 'https://cdnjs.cloudflare.com/ajax/libs/monaco-editor/0.45.0/min/vs' } });

        require(['vs/editor/editor.main'], function () {
            // Define CUDA as an extension of C++
            monaco.languages.register({ id: 'cuda' });
            monaco.languages.setMonarchTokensProvider('cuda', {
                defaultToken: '',
                tokenPostfix: '.cu',
                keywords: [
                    '__global__', '__device__', '__host__', '__shared__', '__constant__',
                    'threadIdx', 'blockIdx', 'blockDim', 'gridDim', 'warpSize',
                    '__syncthreads', '__syncwarp', 'atomicAdd', 'atomicSub', 'atomicMax', 'atomicMin',
                    'atomicExch', 'atomicCAS', '__ldg', '__shfl_sync', '__shfl_down_sync',
                    'cudaMalloc', 'cudaFree', 'cudaMemcpy', 'cudaMemset', 'cudaDeviceSynchronize',
                    'dim3', 'float4', 'float2', 'int4', 'int2', 'uint4', 'uint2',
                    'auto', 'break', 'case', 'catch', 'class', 'const', 'continue',
                    'default', 'delete', 'do', 'else', 'enum', 'explicit', 'extern',
                    'false', 'for', 'friend', 'goto', 'if', 'inline', 'mutable',
                    'namespace', 'new', 'operator', 'private', 'protected', 'public',
                    'register', 'return', 'sizeof', 'static', 'struct', 'switch',
                    'template', 'this', 'throw', 'true', 'try', 'typedef', 'typename',
                    'union', 'unsigned', 'virtual', 'void', 'volatile', 'while'
                ],
                typeKeywords: [
                    'bool', 'char', 'double', 'float', 'int', 'long', 'short', 'signed',
                    'size_t', 'unsigned', 'void', 'wchar_t'
                ],
                operators: [
                    '=', '>', '<', '!', '~', '?', ':', '==', '<=', '>=', '!=',
                    '&&', '||', '++', '--', '+', '-', '*', '/', '&', '|', '^', '%',
                    '<<', '>>', '>>>', '+=', '-=', '*=', '/=', '&=', '|=', '^=',
                    '%=', '<<=', '>>=', '>>>='
                ],
                symbols: /[=><!~?:&|+\-*\/\^%]+/,
                escapes: /\\(?:[abfnrtv\\"']|x[0-9A-Fa-f]{1,4}|u[0-9A-Fa-f]{4}|U[0-9A-Fa-f]{8})/,
                tokenizer: {
                    root: [
                        [/#\s*(define|include|if|ifdef|ifndef|elif|else|endif|pragma|error|warning|undef|line)\b/, 'keyword.directive'],
                        [/[a-z_$][\w$]*/, {
                            cases: {
                                '@typeKeywords': 'keyword.type',
                                '@keywords': 'keyword',
                                '@default': 'identifier'
                            }
                        }],
                        [/[A-Z][\w\$]*/, 'type.identifier'],
                        { include: '@whitespace' },
                        [/[{}()\[\]]/, '@brackets'],
                        [/[<>](?!@symbols)/, '@brackets'],
                        [/@symbols/, {
                            cases: {
                                '@operators': 'operator',
                                '@default': ''
                            }
                        }],
                        [/\d*\.\d+([eE][\-+]?\d+)?[fFdD]?/, 'number.float'],
                        [/0[xX][0-9a-fA-F]+/, 'number.hex'],
                        [/\d+/, 'number'],
                        [/[;,.]/, 'delimiter'],
                        [/"([^"\\]|\\.)*$/, 'string.invalid'],
                        [/"/, 'string', '@string'],
                        [/'[^\\']'/, 'string'],
                        [/(')(@escapes)(')/, ['string', 'string.escape', 'string']],
                        [/'/, 'string.invalid']
                    ],
                    whitespace: [
                        [/[ \t\r\n]+/, 'white'],
                        [/\/\*/, 'comment', '@comment'],
                        [/\/\/.*$/, 'comment']
                    ],
                    comment: [
                        [/[^\/*]+/, 'comment'],
                        [/\/\*/, 'comment', '@push'],
                        [/\*\//, 'comment', '@pop'],
                        [/[\/*]/, 'comment']
                    ],
                    string: [
                        [/[^\\"]+/, 'string'],
                        [/@escapes/, 'string.escape'],
                        [/\\./, 'string.escape.invalid'],
                        [/"/, 'string', '@pop']
                    ]
                }
            });

            monaco.editor.defineTheme('kernel-dark', {
                base: 'vs-dark',
                inherit: true,
                rules: [
                    // Avoid fallback fonts when a font variant isn't available (e.g. italic/bold directives).
                    { token: 'keyword.directive', fontStyle: '' },
                ],
                colors: {}
            });

            // Create editor
            editor = monaco.editor.create(editorContainer, {
                value: '// Select a problem from the sidebar to get started\n',
                language: 'cuda',
                theme: 'kernel-dark',
                fontSize: 14,
                fontFamily: "'Fira Code', 'Cascadia Code', 'JetBrains Mono', Menlo, Monaco, monospace",
                fontLigatures: true,
                minimap: { enabled: true },
                scrollBeyondLastLine: false,
                automaticLayout: true,
                tabSize: 4,
                insertSpaces: true,
                lineNumbers: 'on',
                renderLineHighlight: 'line',
                cursorBlinking: 'smooth',
                smoothScrolling: true,
                padding: { top: 10, bottom: 10 }
            });

            // Initialize app after editor is ready
            init();
        });

        function scheduleIdle(fn) {
            if (window.requestIdleCallback) {
                window.requestIdleCallback(fn, { timeout: 1000 });
            } else {
                setTimeout(fn, 0);
            }
        }

        // Initialize app
        async function init() {
            // Load problems
            await loadProblems();

            // Event listeners
            submitBtn.addEventListener('click', handleSubmit);
            resetBtn.addEventListener('click', handleReset);
            clearConsoleBtn.addEventListener('click', clearConsole);
            profileBtn.addEventListener('click', openProfile);
            profileClose.addEventListener('click', closeProfile);
            profileModal.addEventListener('click', (e) => {
                if (e.target === profileModal) closeProfile();
            });
            loginBtn.addEventListener('click', openAuthModal);
            logoutBtn.addEventListener('click', handleLogout);
            authClose.addEventListener('click', closeAuthModal);
            authModal.addEventListener('click', (e) => {
                if (e.target === authModal) closeAuthModal();
            });
            loginSubmit.addEventListener('click', () => handleLogin({ mode: 'login' }));
            signupSubmit.addEventListener('click', () => handleLogin({ mode: 'signup' }));
            authPassword.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') handleLogin({ mode: 'login' });
            });
            submissionClose.addEventListener('click', closeSubmissionModal);
            submissionModal.addEventListener('click', (e) => {
                if (e.target === submissionModal) closeSubmissionModal();
            });
            submissionCopy.addEventListener('click', copyActiveSubmission);
            submissionLoad.addEventListener('click', loadActiveSubmissionIntoEditor);
            leaderboardList.addEventListener('click', handleLeaderboardClick);
            document.addEventListener('keydown', (e) => {
                if (e.key === 'Escape') {
                    closeProfile();
                    closeSubmissionModal();
                    closeAuthModal();
                }
            });

            setupSplitters();
            updateAuthUI();
        }

        function getAuth() {
            const userId = localStorage.getItem(AUTH_USER_ID_KEY);
            const token = localStorage.getItem(AUTH_TOKEN_KEY);
            if (!userId || !token) return null;
            return { userId, token };
        }

        function setAuth(userId, token) {
            localStorage.setItem(AUTH_USER_ID_KEY, userId);
            localStorage.setItem(AUTH_TOKEN_KEY, token);
            updateAuthUI();
        }

        function clearAuth() {
            localStorage.removeItem(AUTH_USER_ID_KEY);
            localStorage.removeItem(AUTH_TOKEN_KEY);
            updateAuthUI();
        }

        function updateAuthUI() {
            const auth = getAuth();
            if (auth) {
                authUser.textContent = `Logged in as ${auth.userId}`;
                loginBtn.style.display = 'none';
                logoutBtn.style.display = 'inline-block';
                submitBtn.disabled = !currentProblem;
            } else {
                authUser.textContent = 'Not logged in';
                loginBtn.style.display = 'inline-block';
                logoutBtn.style.display = 'none';
                submitBtn.disabled = true;
            }
        }

        function openAuthModal() {
            authTitle.textContent = 'Login';
            authStatus.style.display = 'none';
            authStatus.textContent = '';
            authUsername.value = localStorage.getItem(AUTH_USER_ID_KEY) || '';
            authPassword.value = '';
            authModal.classList.add('open');
            setTimeout(() => authUsername.focus(), 0);
        }

        function closeAuthModal() {
            authModal.classList.remove('open');
        }

        async function handleLogin({ mode }) {
            const userId = authUsername.value.trim();
            const password = authPassword.value;
            if (!userId || !password) {
                authStatus.style.display = 'block';
                authStatus.textContent = 'Username and password required.';
                return;
            }

            authStatus.style.display = 'block';
            authStatus.textContent = mode === 'signup' ? 'Creating account…' : 'Logging in…';

            try {
                if (mode === 'signup') {
                    const created = await fetchApi('signup', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ user_id: userId, password })
                    });
                    if (!created?.success) {
                        authStatus.textContent = created?.message || created?.error || 'Sign up failed.';
                        return;
                    }
                }

                const data = await fetchApi('login', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ user_id: userId, password })
                });
                if (!data?.success || !data?.token || !data?.user_id) {
                    authStatus.textContent = data?.message || data?.error || 'Login failed.';
                    return;
                }

                setAuth(data.user_id, data.token);
                closeAuthModal();
                log(`Logged in as "${data.user_id}"`, 'success');
                if (currentProblem) {
                    await maybeLoadMyLastSubmission(currentProblem.id);
                }
            } catch (e) {
                authStatus.textContent = `Failed: ${e.message || e}`;
            }
        }

        async function handleLogout() {
            const auth = getAuth();
            if (!auth) return;
            try {
                await fetchApi('logout', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ token: auth.token })
                });
            } catch {
                // Best-effort.
            } finally {
                clearAuth();
                log('Logged out', 'info');
            }
        }

        function clamp(value, min, max) {
            return Math.min(max, Math.max(min, value));
        }

        function setSidebarWidthPx(px, { persist = true } = {}) {
            const clamped = clamp(Math.round(px), 240, 560);
            document.documentElement.style.setProperty('--sidebar-width', `${clamped}px`);
            if (persist) localStorage.setItem('leaderboard_sidebar_width', String(clamped));
        }

        function getConsoleMaxHeightPx() {
            const container = document.querySelector('.editor-container');
            const header = document.querySelector('.editor-header');
            if (!container || !header) return 520;
            const containerH = container.getBoundingClientRect().height;
            const headerH = header.getBoundingClientRect().height;
            const minEditorPx = 160;
            const splittersPx = 6;
            return Math.max(140, Math.floor(containerH - headerH - minEditorPx - splittersPx));
        }

        function setConsoleHeightPx(px, { persist = true } = {}) {
            const maxH = getConsoleMaxHeightPx();
            const clamped = clamp(Math.round(px), 140, maxH);
            document.documentElement.style.setProperty('--console-height', `${clamped}px`);
            if (persist) localStorage.setItem('leaderboard_console_height', String(clamped));
        }

        function setupSplitters() {
            const savedSidebar = Number(localStorage.getItem('leaderboard_sidebar_width'));
            if (Number.isFinite(savedSidebar) && savedSidebar > 0) setSidebarWidthPx(savedSidebar, { persist: false });

            const savedConsole = Number(localStorage.getItem('leaderboard_console_height'));
            if (Number.isFinite(savedConsole) && savedConsole > 0) setConsoleHeightPx(savedConsole, { persist: false });

            sidebarSplitter.addEventListener('pointerdown', (e) => {
                e.preventDefault();
                document.body.classList.add('resizing');
                sidebarSplitter.setPointerCapture(e.pointerId);
                const startX = e.clientX;
                const startW = sidebar.getBoundingClientRect().width;

                const onMove = (ev) => {
                    const delta = ev.clientX - startX;
                    setSidebarWidthPx(startW + delta);
                };
                const onUp = () => {
                    document.body.classList.remove('resizing');
                    window.removeEventListener('pointermove', onMove);
                    window.removeEventListener('pointerup', onUp);
                };
                window.addEventListener('pointermove', onMove);
                window.addEventListener('pointerup', onUp, { once: true });
            });

            consoleSplitter.addEventListener('pointerdown', (e) => {
                e.preventDefault();
                document.body.classList.add('resizing');
                consoleSplitter.setPointerCapture(e.pointerId);
                const startY = e.clientY;
                const startH = consoleContainer.getBoundingClientRect().height;

                const onMove = (ev) => {
                    const delta = ev.clientY - startY;
                    setConsoleHeightPx(startH - delta);
                };
                const onUp = () => {
                    document.body.classList.remove('resizing');
                    window.removeEventListener('pointermove', onMove);
                    window.removeEventListener('pointerup', onUp);
                };
                window.addEventListener('pointermove', onMove);
                window.addEventListener('pointerup', onUp, { once: true });
            });

            window.addEventListener('resize', () => {
                const current = Number.parseInt(getComputedStyle(document.documentElement).getPropertyValue('--console-height'), 10);
                if (Number.isFinite(current)) setConsoleHeightPx(current);
            });
        }

        // API helpers
        function buildUrl(endpointWithParams) {
            // Split endpoint and query string: "leaderboard?problem_id=x" -> ["leaderboard", "problem_id=x"]
            const [endpoint, queryString] = endpointWithParams.split('?');
            const query = queryString ? `?${queryString}` : '';
            // Single ASGI app deployment: same-origin paths (works both locally and on Modal).
            return `/${endpoint}${query}`;
        }

        async function fetchApi(endpoint, options = {}) {
            const url = buildUrl(endpoint);
            console.log(`Fetching: ${url}`);
            const response = await fetch(url, options);
            return response.json();
        }

        async function fetchStub(problemId) {
            if (stubCache.has(problemId)) return stubCache.get(problemId);
            if (stubFetches.has(problemId)) return stubFetches.get(problemId);

            const promise = (async () => {
                const data = await fetchApi(`stub?problem_id=${problemId}`);
                const stubText = data?.stub;
                if (!stubText) {
                    throw new Error(data?.error || 'Failed to load stub');
                }
                stubCache.set(problemId, stubText);
                return stubText;
            })();

            stubFetches.set(problemId, promise);
            try {
                return await promise;
            } finally {
                stubFetches.delete(problemId);
            }
        }

        async function preloadStubs() {
            try {
                const data = await fetchApi('stubs');
                const allStubs = data?.stubs || {};
                for (const [problemId, stubText] of Object.entries(allStubs)) {
                    if (typeof stubText === 'string' && stubText) {
                        stubCache.set(problemId, stubText);
                    }
                }
                scheduleIdle(warmProblemModels);
            } catch {
                // Best-effort: individual stub loads will still work.
            }
        }

        function warmProblemModels() {
            const queue = problems.map(p => p.id).filter(pid => !modelsByProblemId.has(pid) && stubCache.has(pid));
            const step = () => {
                const nextId = queue.shift();
                if (!nextId) return;
                const stubText = stubCache.get(nextId);
                if (typeof stubText === 'string') {
                    const model = monaco.editor.createModel(stubText, 'cuda');
                    modelsByProblemId.set(nextId, { model, originalStub: stubText });
                }
                if (queue.length > 0) scheduleIdle(step);
            };
            scheduleIdle(step);
        }

        async function fetchLeaderboardData(problemId, { force = false } = {}) {
            const cached = leaderboardCache.get(problemId);
            const now = Date.now();
            if (!force && cached && (now - cached.fetchedAtMs) < LEADERBOARD_TTL_MS) {
                return cached.data;
            }
            if (!force && leaderboardFetches.has(problemId)) {
                return leaderboardFetches.get(problemId);
            }

            const promise = (async () => {
                const data = await fetchApi(`leaderboard?problem_id=${problemId}`);
                leaderboardCache.set(problemId, { data, fetchedAtMs: Date.now() });
                return data;
            })();

            leaderboardFetches.set(problemId, promise);
            try {
                return await promise;
            } finally {
                leaderboardFetches.delete(problemId);
            }
        }

        function renderLeaderboard(problemId, data) {
            if (!currentProblem || currentProblem.id !== problemId) return;
            const rankings = data?.rankings || [];

            if (rankings.length === 0) {
                leaderboardList.innerHTML = '<li class="empty-state">No submissions yet</li>';
                return;
            }

            leaderboardList.innerHTML = rankings.slice(0, 10).map((r, i) => {
                const rankClass = i === 0 ? 'gold' : i === 1 ? 'silver' : i === 2 ? 'bronze' : '';
                const submissionId = r.best_submission_id;
                const codeBtn = submissionId ? `<button class="leaderboard-btn" type="button" data-submission-id="${submissionId}">Code</button>` : '';
                return `
                    <li>
                        <span class="leaderboard-rank ${rankClass}">${r.rank}.</span>
                        <span class="leaderboard-user">${escapeHtml(r.user_id)}</span>
                        <span class="leaderboard-time">${r.best_time_ms.toFixed(4)}ms</span>
                        ${codeBtn}
                    </li>
                `;
            }).join('');
        }

        async function ensureLeaderboard(problemId, { render = true, force = false, token = null } = {}) {
            if (render && currentProblem && currentProblem.id === problemId) {
                leaderboardList.innerHTML = '<li class="empty-state">Loading…</li>';
            }
            try {
                const data = await fetchLeaderboardData(problemId, { force });
                if (token !== null && token !== selectionToken) return;
                if (render) renderLeaderboard(problemId, data);
            } catch {
                if (token !== null && token !== selectionToken) return;
                if (render && currentProblem && currentProblem.id === problemId) {
                    leaderboardList.innerHTML = '<li class="empty-state">Failed to load</li>';
                }
            }
        }

        function preloadLeaderboards() {
            const ids = problems.map(p => p.id);
            let i = 0;
            const concurrency = 2;

            const pump = async () => {
                while (i < ids.length) {
                    const problemId = ids[i++];
                    await ensureLeaderboard(problemId, { render: false });
                }
            };

            for (let c = 0; c < concurrency; c++) {
                scheduleIdle(() => pump());
            }
        }

        async function loadProblems() {
            try {
                const data = await fetchApi('problems');
                problems = data.problems || [];
                renderProblemList();

                // Select first problem by default
                if (problems.length > 0) {
                    selectProblem(problems[0].id);
                }

                // Best-effort preloading to make switching snappy.
                scheduleIdle(preloadStubs);
                scheduleIdle(preloadLeaderboards);
            } catch (error) {
                log('Failed to load problems: ' + error.message, 'error');
                problemList.innerHTML = '<li class="empty-state">Failed to load problems</li>';
            }
        }

        function renderProblemList() {
            problemList.innerHTML = problems.map(p => `
                <li data-id="${escapeHtml(p.id)}" class="${currentProblem?.id === p.id ? 'active' : ''}">
                    ${escapeHtml(p.name)}
                </li>
            `).join('');

            if (!problemListClickBound) {
                problemList.addEventListener('click', (e) => {
                    const li = e.target.closest('li[data-id]');
                    if (!li) return;
                    selectProblem(li.dataset.id);
                });
                problemListClickBound = true;
            }
        }

        function updateActiveProblemInList(problemId) {
            const prev = problemList.querySelector('li.active');
            if (prev) prev.classList.remove('active');
            const escapedId = (window.CSS && CSS.escape) ? CSS.escape(problemId) : String(problemId).replaceAll('"', '\\"');
            const next = problemList.querySelector(`li[data-id="${escapedId}"]`);
            if (next) next.classList.add('active');
        }

        async function selectProblem(problemId) {
            const problem = problems.find(p => p.id === problemId);
            if (!problem) return;
            if (currentProblem && currentProblem.id === problemId) return;

            currentProblem = problem;
            selectionToken += 1;
            const token = selectionToken;
            updateActiveProblemInList(problemId);
            filenameTab.textContent = `${problemId}.cu`;
            submitBtn.disabled = !getAuth();

            // Kick off leaderboard load early (may render immediately from cache).
            const leaderboardPromise = ensureLeaderboard(problemId, { render: true, force: false, token });

            // Swap editor model as quickly as possible.
            try {
                const existing = modelsByProblemId.get(problemId);
                if (existing?.model) {
                    editor.setModel(existing.model);
                    renderProblemInfo(existing.originalStub);
                } else {
                    const stubText = await fetchStub(problemId);
                    if (token !== selectionToken) return;
                    const model = monaco.editor.createModel(stubText, 'cuda');
                    modelsByProblemId.set(problemId, { model, originalStub: stubText });
                    editor.setModel(model);
                    renderProblemInfo(stubText);
                }
            } catch (error) {
                log('Failed to load problem: ' + error.message, 'error');
            }

            await maybeLoadMyLastSubmission(problemId);
            await leaderboardPromise;
        }

        async function maybeLoadMyLastSubmission(problemId) {
            const auth = getAuth();
            if (!auth || !problemId) return;

            const entry = modelsByProblemId.get(problemId);
            const model = editor?.getModel?.();
            if (!entry?.originalStub || !model) return;

            const current = model.getValue();
            const data = await fetchApi(`my_last_submission?problem_id=${encodeURIComponent(problemId)}&token=${encodeURIComponent(auth.token)}`);
            if (!data || data.error) {
                if (data?.error === 'unauthorized') {
                    clearAuth();
                    log('Session expired. Please log in again.', 'warning');
                }
                return;
            }
            if (typeof data.kernel_source !== 'string' || !data.kernel_source) return;
            if (current === data.kernel_source) return;

            const isPristine = current === entry.originalStub;
            if (!isPristine) {
                if (!confirm('Load your last submission for this problem? This will replace the editor contents.')) return;
            }

            setEditorContent(data.kernel_source);
            log(`Loaded your last submission for ${problemId} (${data.kernel_hash || 'no hash'})`, 'info');
        }

        function renderProblemInfo(stubContent) {
            // Parse comment block from stub
            const commentMatch = stubContent.match(/\/\*\s*([\s\S]*?)\*\//);
            if (!commentMatch) {
                problemInfo.innerHTML = `
                    <h3>Problem Info</h3>
                    <div class="problem-name">${currentProblem.name}</div>
                `;
                return;
            }

            const comment = commentMatch[1];
            const lines = comment.split('\n').map(l => l.replace(/^\s*\*\s?/, '').trim());

            // Extract parts
            let name = currentProblem.name;
            let chapter = '';
            let description = [];
            let inDescription = false;

            for (const line of lines) {
                if (line.startsWith('Problem:')) {
                    name = line.replace('Problem:', '').trim();
                } else if (line.startsWith('PMPP')) {
                    chapter = line;
                } else if (line && !line.startsWith('Input:') && !line.startsWith('Output:') &&
                           !line.startsWith('Key concepts:') && !line.startsWith('Optimization')) {
                    description.push(line);
                }
            }

            problemInfo.innerHTML = `
                <h3>Problem Info</h3>
                <div class="problem-name">${name}</div>
                ${chapter ? `<div class="problem-chapter">${chapter}</div>` : ''}
                <div class="problem-description">${description.slice(0, 5).join('\n')}</div>
            `;
        }

        function setEditorContent(content) {
            const model = editor.getModel();
            if (model) {
                model.setValue(content);
            } else {
                editor.setValue(content);
            }
        }

        function getEditorContent() {
            const model = editor.getModel();
            return model ? model.getValue() : editor.getValue();
        }

        // Security: Escape HTML to prevent XSS attacks
        function escapeHtml(str) {
            if (!str) return '';
            const div = document.createElement('div');
            div.textContent = str;
            return div.innerHTML;
        }

        async function handleSubmit() {
            if (!currentProblem || isSubmitting) return;

            const auth = getAuth();
            if (!auth) {
                openAuthModal();
                log('Login required to submit.', 'warning');
                return;
            }
            const kernelSource = getEditorContent();

            if (!kernelSource.trim()) {
                log('Error: No code to submit', 'error');
                return;
            }

            isSubmitting = true;
            submitBtn.disabled = true;
            submitBtn.innerHTML = '<span class="spinner"></span>Submitting...';

            log(`Submitting to ${currentProblem.id} as "${auth.userId}"...`, 'info');

            try {
                const result = await fetchApi('submit', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        problem_id: currentProblem.id,
                        kernel_source: kernelSource,
                        token: auth.token
                    })
                });

                if (result.success) {
                    log(`Success! Median time: ${result.time_ms.toFixed(4)} ms`, 'success');
                    log(`All runs: ${result.times.map(t => t.toFixed(4)).join(', ')} ms`, 'info');
                    log(`Kernel hash: ${result.kernel_hash}`, 'info');

                    // Refresh leaderboard
                    leaderboardCache.delete(currentProblem.id);
                    await ensureLeaderboard(currentProblem.id, { render: true, force: true, token: selectionToken });
                } else {
                    log(`Submission failed: ${result.error}`, 'error');
                    if (result.message) {
                        // Format compilation errors nicely
                        const msg = result.message;
                        if (msg.includes('error:')) {
                            msg.split('\n').forEach(line => {
                                if (line.trim()) log(line, 'error');
                            });
                        } else {
                            log(result.message, 'error');
                        }
                    }
                }
            } catch (error) {
                log('Network error: ' + error.message, 'error');
            } finally {
                isSubmitting = false;
                submitBtn.disabled = !getAuth();
                submitBtn.textContent = 'Submit';
            }
        }

        function openProfile() {
            const auth = getAuth();
            if (!auth) {
                openAuthModal();
                return;
            }
            profileModal.classList.add('open');
            loadProfile(auth.userId);
        }

        function closeProfile() {
            profileModal.classList.remove('open');
        }

        async function handleLeaderboardClick(e) {
            const btn = e.target.closest('button[data-submission-id]');
            if (!btn) return;
            const submissionId = btn.getAttribute('data-submission-id');
            if (!submissionId) return;
            await openSubmissionModal(submissionId);
        }

        function closeSubmissionModal() {
            submissionModal.classList.remove('open');
            activeSubmission = null;
            submissionTitle.textContent = 'Submission';
            submissionCode.textContent = '';
        }

        async function openSubmissionModal(submissionId) {
            submissionModal.classList.add('open');
            submissionTitle.textContent = 'Loading…';
            submissionCode.textContent = 'Loading…';
            submissionCopy.disabled = true;
            submissionLoad.disabled = true;

            try {
                const data = await fetchApi(`submission?submission_id=${encodeURIComponent(submissionId)}`);
                if (!data?.submission_id) throw new Error('Bad submission payload');
                activeSubmission = data;
                submissionTitle.textContent = `${data.problem_id} · ${data.user_id} · ${Number(data.time_ms).toFixed(4)}ms`;
                submissionCode.textContent = data.kernel_source || '(no source stored)';
                submissionCopy.disabled = false;
                submissionLoad.disabled = false;
            } catch (e) {
                activeSubmission = null;
                submissionTitle.textContent = 'Failed to load';
                submissionCode.textContent = `${e.message || e}`;
            }
        }

        async function copyActiveSubmission() {
            if (!activeSubmission || typeof activeSubmission.kernel_source !== 'string') return;
            const text = activeSubmission.kernel_source;
            try {
                await navigator.clipboard.writeText(text);
                log('Copied submission code to clipboard', 'success');
            } catch {
                const ta = document.createElement('textarea');
                ta.value = text;
                ta.style.position = 'fixed';
                ta.style.left = '-9999px';
                document.body.appendChild(ta);
                ta.select();
                document.execCommand('copy');
                ta.remove();
                log('Copied submission code to clipboard', 'success');
            }
        }

        async function loadActiveSubmissionIntoEditor() {
            if (!activeSubmission || typeof activeSubmission.kernel_source !== 'string') return;
            const shouldConfirm = (() => {
                if (!currentProblem) return true;
                const model = editor?.getModel?.();
                const entry = modelsByProblemId.get(currentProblem.id);
                if (!model || !entry?.originalStub) return true;
                return model.getValue() !== entry.originalStub;
            })();
            if (shouldConfirm && !confirm('Replace current editor contents with this submission?')) return;
            await loadSubmissionIntoEditor(activeSubmission.submission_id);
            closeSubmissionModal();
        }

        async function loadProfile(username) {
            profileStatus.textContent = 'Loading…';
            profileStatus.style.display = 'block';
            profileBestTitle.style.display = 'none';
            profileRecentTitle.style.display = 'none';
            profileBest.innerHTML = '';
            profileList.innerHTML = '';

            try {
                const data = await fetchApi(`profile?user_id=${encodeURIComponent(username)}&limit=100`);
                const recent = data?.recent || [];
                const best = data?.best_by_problem || [];

                if (best.length === 0 && recent.length === 0) {
                    profileStatus.textContent = 'No submissions yet.';
                    return;
                }

                profileStatus.style.display = 'none';

                if (best.length > 0) {
                    profileBestTitle.style.display = 'block';
                    profileBest.innerHTML = best.map((r) => `
                        <li>
                            <div class="profile-problem">${escapeHtml(r.problem_name)} <span style="color: var(--text-muted);">(${escapeHtml(r.problem_id)})</span></div>
                            <div class="profile-time">${Number(r.best_time_ms).toFixed(4)}ms</div>
                            <div class="profile-meta"></div>
                        </li>
                    `).join('');
                }

                if (recent.length > 0) {
                    profileRecentTitle.style.display = 'block';
                }
                profileList.innerHTML = recent.map((r) => `
                    <li>
                        <div class="profile-problem">${escapeHtml(r.problem_name)} <span style="color: var(--text-muted);">(${escapeHtml(r.problem_id)})</span></div>
                        <div class="profile-time">${Number(r.time_ms).toFixed(4)}ms</div>
                        <div class="profile-meta">${escapeHtml(r.submitted_at)} · ${escapeHtml(r.kernel_hash || '')}</div>
                        <button class="profile-btn" type="button" data-submission-id="${r.submission_id}">Load</button>
                    </li>
                `).join('');

                profileList.querySelectorAll('button[data-submission-id]').forEach(btn => {
                    btn.addEventListener('click', async () => {
                        const id = btn.getAttribute('data-submission-id');
                        if (!id) return;
                        await loadSubmissionIntoEditor(id);
                        closeProfile();
                    });
                });
            } catch (e) {
                profileStatus.textContent = `Failed to load profile: ${e.message || e}`;
            }
        }

        async function loadSubmissionIntoEditor(submissionId) {
            try {
                const data = await fetchApi(`submission?submission_id=${encodeURIComponent(submissionId)}`);
                if (!data?.problem_id) throw new Error('Bad submission payload');
                if (typeof data?.kernel_source !== 'string') throw new Error('Missing kernel source');
                await selectProblem(data.problem_id);
                setEditorContent(data.kernel_source);
                log(`Loaded submission ${submissionId} (${data.kernel_hash || 'no hash'})`, 'info');
            } catch (e) {
                log(`Failed to load submission: ${e.message || e}`, 'error');
            }
        }

        function handleReset() {
            if (!currentProblem) return;
            const entry = modelsByProblemId.get(currentProblem.id);
            if (entry?.originalStub) {
                entry.model.setValue(entry.originalStub);
                log('Editor reset to original stub', 'info');
            }
        }

        function log(message, type = 'info') {
            const line = document.createElement('div');
            line.className = `console-line ${type}`;
            line.textContent = `> ${message}`;
            consoleOutput.appendChild(line);
            consoleOutput.scrollTop = consoleOutput.scrollHeight;
        }

        function clearConsole() {
            consoleOutput.innerHTML = '';
        }

        // App is started inside the require() callback after Monaco loads
    </script>
</body>
</html>
